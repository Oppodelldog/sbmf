// this code has been generated by sbmf (https://github.com/Oppodelldog/sbmf), do not change it manually
// @formatter:off
package {{.Package}}

import (
"bytes"
"encoding/binary"
"errors"
"fmt"
"io"
"reflect"
)

type numerics interface {
    ~int8 | ~int16 | ~int32 | ~int64 |
    ~uint8 | ~uint16 | ~uint32 | ~uint64 |
    ~float32 | ~float64
}

type mapValues interface {
    numerics | ~string
}


var ErrUnknownMessage = errors.New("unknown message")

const (
    // Messages
{{- range $name, $id := .MessageIDs }}
    {{ messageIdName $name }} = int8({{ $id }})
{{- end }}
)
const (
    // Enums
{{- range $name, $values := .Enums }}
    {{- range $values }}
        {{$name}}{{.Name}} {{$name}} = {{.Value}}
    {{- end }}
{{- end }}
)

type (
    // CustomTypes
{{- range $name, $type := .CustomTypes }}
    {{ .Name }} {{ typeDef . }}
{{- end }}

    // Enums
{{- range $name, $values := .Enums }}
    {{- if typeDoesNotExist $name }}
        {{ $name }} int32
    {{- end }}
{{- end }}

    // Messages
{{- range $name, $fields := .Messages }}
    {{ $name }} struct {
    {{- range $fields }}
        {{ .Name }} {{ typeDef . }}
    {{- end }}
    }
{{- end }}
)

func unmarshal(v interface{}, r io.Reader) error {
    switch v := v.(type) {
    case *string:
        return unmarshalString(r, v)

    // Messages
{{- range $name, $fields := .Messages }}
    case *{{ $name }}:
    return v.UnmarshalBinary(r)
{{- end }}

    // Enums
{{- range $name, $values := .Enums }}
{{- if typeDoesNotExist $name }}
    case *{{$name}}:
    var i int32
    e := binary.Read(r, binary.LittleEndian, &i)
    if e != nil {
        return fmt.Errorf("err unmarshal {{$name}}: %w", e)
    }
    *v = {{$name}}(i)

    return nil
{{- end }}
{{- end }}

    // CustomTypes
{{- range .CustomTypes }}
    case *{{ .Name }}:
    var t {{ typeDef . }}
    var e=unmarshal(&t,r)
    if e != nil {
    return fmt.Errorf("err unmarshal {{ .Name }}: %w", e)
    }
    *v = {{ .Name }}(t)
    return nil
{{- end }}

    // ListTypes
{{- range $type := listTypes }}
    case *{{ typeDef $type }}:
        return unmarshalSlice(r,v)
{{- end }}

    // MapTypes
{{- range $type := mapTypes }}
    case *{{ typeDef $type }}:
    return unmarshalMap(r,v)
{{- end }}

    default:
     return binary.Read(r, binary.LittleEndian, v)
    }
}

func marshal(v interface{}, w io.Writer) error {
    switch v := v.(type) {
    case string:
        return marshalString(w, v)

    // Messages
{{- range $name, $fields := .Messages }}
    case {{ $name }}:
    d, e := v.MarshalBinary()
    if e != nil {
        return fmt.Errorf("err marshal {{ $name }}: %w", e)
    }
    _, e = w.Write(d)
    if e != nil {
        return fmt.Errorf("err write {{ $name }}: %w", e)
    }
    return nil
{{- end }}

    // Enums
{{- range $name, $values := .Enums }}
{{- if typeDoesNotExist $name }}
    case {{ $name }}:
    return binary.Write(w, binary.LittleEndian, int32(v))
{{- end }}
{{- end }}

    // CustomTypes
{{- range  .CustomTypes }}
    case {{ .Name }}:
    return marshal({{ typeDef . }}(v),w)
{{- end }}

    // ListTypes
{{- range $type := listTypes }}
    case {{ typeDef $type }}:
    return marshalSlice(w,v)
{{- end }}

    // MapTypes
{{- range $type := mapTypes }}
    case {{ typeDef $type }}:
    return marshalMap(w,v)
{{- end }}

    default:
        return binary.Write(w, binary.LittleEndian, v)
    }
}

// Messages
{{- range $name, $fields := .Messages }}
    func (m *{{ $name }}) UnmarshalBinary(r io.Reader) error{
    var e error

    {{- range $fields }}
    if e=unmarshal(&m.{{ .Name }}, r); e != nil {
        return fmt.Errorf("err unmarshal m.{{ .Name }}: %w", e)
    }
    {{- end }}

    return nil
    }

    func (m *{{ $name }}) MarshalBinary() ([]byte, error) {
    var data []byte
    w := bytes.NewBuffer(data)
    var e error

    {{- range $fields }}
    if e=marshal(m.{{ .Name }},w); e != nil {
        return nil, fmt.Errorf("err marshal m.{{ .Name }}: %w", e)
    }
    {{- end }}

    return w.Bytes(),nil
    }
{{- end }}

func marshalPrimitiveSlice[T numerics](w io.Writer, v []T) error {
    length := int32(len(v))
    if err := binary.Write(w, binary.LittleEndian, length); err != nil {
        return fmt.Errorf("err write slice length: %w", err)
    }

    if length == 0 {
        return nil
    }

    if err := binary.Write(w, binary.LittleEndian, v); err != nil {
        return fmt.Errorf("err write %T slice (len=%d): %w", v, length, err)
    }

    return nil
}


func marshalSlice[T any](w io.Writer, v []T) error {
    // Schnellpfad für primitive Typen
    switch any(v).(type) {
    case []float64:
        return marshalPrimitiveSlice(w, any(v).([]float64))
    case []float32:
        return marshalPrimitiveSlice(w, any(v).([]float32))
    case []int32:
        return marshalPrimitiveSlice(w, any(v).([]int32))
    case []int64:
        return marshalPrimitiveSlice(w, any(v).([]int64))
    case []uint8:
        return marshalPrimitiveSlice(w, any(v).([]uint8))
    case []int16:
        return marshalPrimitiveSlice(w, any(v).([]int16))
    // weitere Typen? Einfach hinzufügen
    }

    // Standardweg für Nicht-Primitive
    length := int32(len(v))
    if err := binary.Write(w, binary.LittleEndian, length); err != nil {
        return err
    }

    for i, elem := range v {
        switch vt := any(elem).(type) {
        case string:
            if err := marshalString(w, vt); err != nil {
                return fmt.Errorf("err marshal string at index %d: %w", i, err)
            }
        default:
            if err := marshal(vt, w); err != nil {
                return fmt.Errorf("err marshal slice element %d: %w", i, err)
            }
        }
    }

    return nil
}

func unmarshalPrimitiveSlice[T numerics](r io.Reader, v *[]T) error {
    var length int32
    if err := binary.Read(r, binary.LittleEndian, &length); err != nil {
        return fmt.Errorf("err read slice length: %w", err)
    }

    if length < 0 {
        return fmt.Errorf("invalid slice length: %d", length)
    }

    *v = make([]T, length)
    if err := binary.Read(r, binary.LittleEndian, *v); err != nil {
        return fmt.Errorf("err read %T slice (len=%d): %w", *v, length, err)
    }

    return nil
}

func unmarshalSlice[T any](r io.Reader, v *[]T) error {
    // Spezialfall: T ist numerics → direkt schnell verarbeiten
    switch any(v).(type) {
    case *[]float64:
        return unmarshalPrimitiveSlice(r, any(v).(*[]float64))
    case *[]float32:
        return unmarshalPrimitiveSlice(r, any(v).(*[]float32))
    case *[]int32:
        return unmarshalPrimitiveSlice(r, any(v).(*[]int32))
    case *[]int64:
        return unmarshalPrimitiveSlice(r, any(v).(*[]int64))
    case *[]uint8:
        return unmarshalPrimitiveSlice(r, any(v).(*[]uint8))
    case *[]int16:
        return unmarshalPrimitiveSlice(r, any(v).(*[]int16))
    // add more if needed
    }

    // Standardweg für Nicht-Primitive
    var length int32
    if err := binary.Read(r, binary.LittleEndian, &length); err != nil {
        return fmt.Errorf("err unmarshal slice length: %w", err)
    }

    if length < 0 {
        return fmt.Errorf("invalid slice length: %d", length)
    }

    slice := make([]T, length)
    for i := range slice {
        if err := unmarshal(&slice[i], r); err != nil {
            return fmt.Errorf("err unmarshal slice element %d/%d: %w", i+1, length, err)
        }
    }

    *v = slice
    return nil
}


func unmarshalString(r io.Reader, v *string) error {
    var l int32
    if e := binary.Read(r, binary.LittleEndian, &l); e != nil {
        return  fmt.Errorf("err read string length: %w", e)
    }

    var b = make([]byte, l)
    e := binary.Read(r, binary.LittleEndian, &b)
    if e != nil {
        return  fmt.Errorf("err read string value (len=%v): %w",l, e)
    }
    *v = string(b)

    return nil
}

func marshalString(w io.Writer, v string) error {
    if e := binary.Write(w, binary.LittleEndian, int32(len(v))); e != nil {
        return fmt.Errorf("err write string length: %w", e)
    }
    _, e := w.Write([]byte(v))
    if e != nil {
        return fmt.Errorf("err write string value (len=%v): %w",len(v), e)
    }

    return nil
}

func WriteMessage(w io.Writer, m interface{}) error {
var messageID int8
    switch m.(type) {
    {{- range $name, $fields := .Messages }}
        case {{ $name }}:
        messageID = {{ messageIdName $name }}
    {{- end }}
    }

    if messageID == 0 {
        return fmt.Errorf("%w: %T", ErrUnknownMessage, m)
    }

    if e :=binary.Write(w, binary.LittleEndian, messageID); e != nil {
        return fmt.Errorf("err write message id: %w", e)
    }

    return marshal(m, w)
}

func ReadMessage(r io.Reader) (interface{}, error) {
    var id int8
    if e := binary.Read(r, binary.LittleEndian, &id); e != nil {
        return nil, fmt.Errorf("err read message id: %w", e)
    }

    switch id {
    {{- range $name, $fields := .Messages }}
        case {{ messageIdName $name }}:
        var m {{ $name }}
        if e := unmarshal(&m, r); e != nil {
            return nil, fmt.Errorf("err unmarshal {{ $name }}: %w", e)
        }
        return m, nil
    {{- end }}
    }

    return nil, fmt.Errorf("%w: %d", ErrUnknownMessage,id)
}

func ReadPacket(r io.Reader) (interface{}, error) {
    var length int32
    if e := binary.Read(r, binary.LittleEndian, &length); e != nil {
        return nil, fmt.Errorf("err read packet length: %w", e)
    }

    var data = make([]byte, length)
    if e := binary.Read(r, binary.LittleEndian, &data); e != nil {
        return nil, fmt.Errorf("err read packet data (len=%v): %w",length, e)
    }

    return ReadMessage(bytes.NewReader(data))
}

func WritePacket(w io.Writer, m interface{}) error {
    var data []byte
    var buffer = bytes.NewBuffer(data)
    if e := WriteMessage(buffer, m); e != nil {
        return fmt.Errorf("err write message: %w", e)
    }

    var length = int32(buffer.Len())
    if e := binary.Write(w, binary.LittleEndian, length); e != nil {
        return fmt.Errorf("err write packet length: %w", e)
    }

    _, e := w.Write(buffer.Bytes())
    if e != nil{
        return fmt.Errorf("err write packet data (len=%v): %w",length, e)
    }

    return nil
}

type PacketReader struct {
    bytes.Buffer
    nextPacketLength int32
}

func (pr *PacketReader) Read(r io.Reader) (interface{}, error) {
    data, err := io.ReadAll(r)
    if err != nil {
        return nil, fmt.Errorf("err read packet: %w", err)
    }

    _, err = pr.Write(data)
    if err != nil {
        return nil, fmt.Errorf("err write packet: %w", err)
    }

    if pr.nextPacketLength == 0 && pr.Len() >= 4 {
        var length int32
        if err = binary.Read(&pr.Buffer, binary.LittleEndian, &length); err != nil {
            return nil, fmt.Errorf("err read packet length: %w", err)
        }
        pr.nextPacketLength = length
    }

    if pr.nextPacketLength > 0 && int32(pr.Len()) >= pr.nextPacketLength {
        var messageData = make([]byte, pr.nextPacketLength)
        if e := binary.Read(&pr.Buffer, binary.LittleEndian, &messageData); e != nil {
            return nil, fmt.Errorf("err read packet data (len=%v): %w",pr.nextPacketLength, e)
        }
        pr.nextPacketLength = 0
        return ReadMessage(bytes.NewReader(messageData))
    }

    return nil, nil
}

func marshalPrimitiveMap[V mapValues](w io.Writer, m map[string]V) error {
    length := int32(len(m))
    if err := binary.Write(w, binary.LittleEndian, length); err != nil {
        return fmt.Errorf("err write map length: %w", err)
    }

    for k, v := range m {
        if err := marshalString(w, k); err != nil {
            return fmt.Errorf("err write map key: %w", err)
        }
        if err := marshal(v, w); err != nil {
            return fmt.Errorf("err write map value: %w", err)
        }
    }

    return nil
}

func marshalMap(w io.Writer, mapValue interface{}) error {
    switch m := mapValue.(type) {
    case map[string]int8:
        return marshalPrimitiveMap(w, m)
    case map[string]int16:
        return marshalPrimitiveMap(w, m)
    case map[string]int32:
        return marshalPrimitiveMap(w, m)
    case map[string]int64:
        return marshalPrimitiveMap(w, m)

    case map[string]uint8:
        return marshalPrimitiveMap(w, m)
    case map[string]uint16:
        return marshalPrimitiveMap(w, m)
    case map[string]uint32:
        return marshalPrimitiveMap(w, m)
    case map[string]uint64:
        return marshalPrimitiveMap(w, m)

    case map[string]float32:
        return marshalPrimitiveMap(w, m)
    case map[string]float64:
        return marshalPrimitiveMap(w, m)

    case map[string]string:
        return marshalPrimitiveMap(w, m)
    }

    mapValueReflect := reflect.ValueOf(mapValue)
    mapLength := mapValueReflect.Len()
    if err := binary.Write(w, binary.LittleEndian, int32(mapLength)); err != nil {
        return fmt.Errorf("err write map length: %w", err)
    }

    for _, key := range mapValueReflect.MapKeys() {
        value := mapValueReflect.MapIndex(key)
        if err := marshal(key.Interface(), w); err != nil {
            return fmt.Errorf("err marshal map key: %w", err)
        }
        if err := marshal(value.Interface(), w); err != nil {
            return fmt.Errorf("err marshal map value: %w", err)
        }
    }

    return nil
}

func unmarshalPrimitiveMap[V mapValues](r io.Reader, m *map[string]V) error {
    var length int32
    if err := binary.Read(r, binary.LittleEndian, &length); err != nil {
        return fmt.Errorf("err read map length: %w", err)
    }

    if length < 0 {
        return fmt.Errorf("invalid map length: %d", length)
    }

    result := make(map[string]V, length)
    for i := int32(0); i < length; i++ {
        var key string
        if err := unmarshalString(r, &key); err != nil {
            return fmt.Errorf("err read map key at %d: %w", i, err)
        }

        var value V
        if err := unmarshal(&value, r); err != nil {
            return fmt.Errorf("err read map value at %d: %w", i, err)
        }

        result[key] = value
    }

    *m = result
    return nil
}

func unmarshalMap(r io.Reader, mp interface{}) error {
    switch m := mp.(type) {
    case *map[string]int8:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]int16:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]int32:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]int64:
        return unmarshalPrimitiveMap(r, m)

    case *map[string]uint8:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]uint16:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]uint32:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]uint64:
        return unmarshalPrimitiveMap(r, m)

    case *map[string]float32:
        return unmarshalPrimitiveMap(r, m)
    case *map[string]float64:
        return unmarshalPrimitiveMap(r, m)

    case *map[string]string:
        return unmarshalPrimitiveMap(r, m)
    }

    rmp := reflect.ValueOf(mp)
    mapReflect := reflect.ValueOf(rmp.Elem().Interface())
    mapType := mapReflect.Type()
    mapValue := reflect.MakeMapWithSize(mapReflect.Type(), 0)

    var mapLength int32
    if err := binary.Read(r, binary.LittleEndian, &mapLength); err != nil {
        return fmt.Errorf("err read map length: %w", err)
    }

    for i := 0; i < int(mapLength); i++ {
        key := reflect.New(mapType.Key()).Interface()
        if err := unmarshal(key, r); err != nil {
            return fmt.Errorf("err unmarshal map key: %w", err)
        }

        value := reflect.New(mapType.Elem()).Interface()
        if err := unmarshal(value, r); err != nil {
            return fmt.Errorf("err unmarshal map value: %w", err)
        }

        mapValue.SetMapIndex(reflect.ValueOf(key).Elem(), reflect.ValueOf(value).Elem())
    }

    rmp.Elem().Set(mapValue)
    return nil
}
